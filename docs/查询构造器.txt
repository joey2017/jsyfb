DB::statement('drop table users');

DB::listen(function ($query) {
      // $query->sql
      // $query->bindings
      // $query->time
});

数据库事务/处理死锁

DB::transaction(function () {
    DB::table('users')->update(['votes' => 1]);

    DB::table('posts')->delete();
},5);

手动使用事务
DB::beginTransaction();
你可以使用 rollBack 方法回滚事务：
DB::rollBack();
最后，你可以使用 commit 方法提交事务：
DB::commit();


从一个数据表中获取所有行

$users = DB::table('users')->get();

该 get 方法返回一个包含 Illuminate\Support\Collection 的结果，其中每个结果都是 PHP StdClass 对象的一个实例。你可以访问字段作为对象的属性来访问每列的值：
foreach ($users as $user) {
    echo $user->name;
}

从数据表中获取单行或单列

$user = DB::table('users')->where('name', 'John')->first();
$email = DB::table('users')->where('name', 'John')->value('email');

获取一列的值
$titles = DB::table('roles')->pluck('title','name');

foreach ($titles as $title) {
    echo $title;
}

分块结果//需要处理上千条数据库记录

DB::table('users')->orderBy('id')->chunk(100, function ($users) {
    foreach ($users as $user) {
        //
        return false;
    }
});
你可以通过在 闭包 中返回 false 来终止继续获取分块结果：


如果要在分块结果时更新数据库记录，则块结果可能会和预计的返回结果不一致。因此，在分块更新记录时，最好使用 chunkById 方法。

DB::table('users')->where('active', false)
    ->chunkById(100, function ($users) {
        foreach ($users as $user) {
            DB::table('users')
                ->where('id', $user->id)
                ->update(['active' => true]);
        }
    });

查询构造器还提供了各种聚合方法，比如 count, max，min， avg，还有 sum。你可以在构造查询后调用任何方法：

$users = DB::table('users')->count();

$price = DB::table('orders')->max('price');

$price = DB::table('orders')
                ->where('finalized', 1)
                ->avg('price');

判断记录是否存在
return DB::table('orders')->where('finalized', 1)->exists();

return DB::table('orders')->where('finalized', 1)->doesntExist();

指定字段
$users = DB::table('users')->select('name', 'email as user_email')->get();

distinct 方法会强制让查询返回的结果不重复：
$users = DB::table('users')->distinct()->get();

添加字段
$query = DB::table('users')->select('name');
$users = $query->addSelect('age')->get();

原生表达式
$users = DB::table('users')
                     ->select(DB::raw('count(*) as user_count, status'))
                     ->where('status', '<>', 1)
                     ->groupBy('status')
                     ->get();


selectRaw 方法可以代替 select(DB::raw(...))

$orders = DB::table('orders')
                ->selectRaw('price * ? as price_with_tax', [1.0825])
                ->get();

whereRaw 和 orWhereRaw 方法将原生的 where
注入到你的查询中。这两个方法的第二个参数还是可选项，值还是绑定参数的数组：

$orders = DB::table('orders')
                ->whereRaw('price > IF(state = "TX", ?, 100)', [200])
                ->get();

havingRaw 和 orHavingRaw 方法可以用于将原生字符串设置为 having 语句的值：
$orders = DB::table('orders')
                ->select('department', DB::raw('SUM(price) as total_sales'))
                ->groupBy('department')
                ->havingRaw('SUM(price) > ?', [2500])
                ->get();

Inner Join Clause

$users = DB::table('users')
            ->join('contacts', 'users.id', '=', 'contacts.user_id')
            ->join('orders', 'users.id', '=', 'orders.user_id')
            ->select('users.*', 'contacts.phone', 'orders.price')
            ->get();

Left Join 语句
$users = DB::table('users')
            ->leftJoin('posts', 'users.id', '=', 'posts.user_id')
            ->get();
     $users = DB::table('users')
            ->rightJoin('posts', 'users.id', '=', 'posts.user_id')

Unions
查询构造器还提供了将两个查询 「联合」 的快捷方式。比如，你可以先创建一个查询，然后使用 union 方法将其和第二个查询进行联合：
            ->get();

$first = DB::table('users')
            ->whereNull('first_name');

$users = DB::table('users')
            ->whereNull('last_name')
            ->union($first)
            ->get();

你也可以使用 unionAll 方法，用法 union 方法是的一样。

$users = DB::table('users')->where('votes', '=', 100)->get();

$users = DB::table('users')->where([
    ['status', '=', '1'],
    ['subscribed', '<>', '1'],
])->get();

$users = DB::table('users')
                    ->where('votes', '>', 100)
                    ->orWhere('name', 'John')
                    ->get();

whereBetween 方法验证字段值是否在给定的两个值之间：
$users = DB::table('users')
                    ->whereBetween('votes', [1, 100])->get();

$users = DB::table('users')
                    ->whereNotBetween('votes', [1, 100])
                    ->get();

$users = DB::table('users')
                    ->whereIn('id', [1, 2, 3])
                    ->get();

$users = DB::table('users')
                    ->whereNotIn('id', [1, 2, 3])
                    ->get();

$users = DB::table('users')
                    ->whereNull('updated_at')
                    ->get();

$users = DB::table('users')
                    ->whereNotNull('updated_at')
                    ->get();

$users = DB::table('users')
                ->whereDate('created_at', '2018-09-08')
                ->get();

$users = DB::table('users')
                ->whereMonth('created_at', '9')
                ->get();

$users = DB::table('users')
                ->whereDay('created_at', '8')
                ->get();

$users = DB::table('users')
                ->whereYear('created_at', '2018')
                ->get();

$users = DB::table('users')
                ->whereTime('created_at', '=', '11:20:45')
                ->get();

$users = DB::table('users')
                ->whereColumn('first_name', 'last_name')
                ->get();

$users = DB::table('users')
                ->whereColumn('updated_at', '>', 'created_at')
                ->get();

$users = DB::table('users')
                ->whereColumn([
                    ['first_name', '=', 'last_name'],
                    ['updated_at', '>', 'created_at']
                ])->get();

DB::table('users')
            ->where('name', '=', 'John')
            ->where(function ($query) {
                $query->where('votes', '>', 100)
                      ->orWhere('title', '=', 'Admin');
            })
            ->get();

Where Exists 语句

DB::table('users')
            ->whereExists(function ($query) {
                $query->select(DB::raw(1))
                      ->from('orders')
                      ->whereRaw('orders.user_id = users.id');
            })
            ->get();

orderBy

$users = DB::table('users')
                ->orderBy('name', 'desc')
                ->get();

latest / oldest
latest 和 oldest 方法可以使你轻松地通过日期排序。它默认使用 created_at 列作为排序依据。当然，你也可以传递自定义的列名：

$user = DB::table('users')
                ->latest()
                ->first();

inRandomOrder
inRandomOrder 方法被用来将结果随机排序。例如，你可以使用此方法随机找到一个用户。

$randomUser = DB::table('users')
                ->inRandomOrder()
                ->first();

groupBy / having
groupBy 和 having 方法可以将结果分组。 having 方法的使用与 where 方法十分相似：

$users = DB::table('users')
                ->groupBy('account_id')
                ->having('account_id', '>', 100)
                ->get();

skip / take
要限制结果的返回数量，或跳过指定数量的结果，你可以使用 skip 和 take 方法：

$users = DB::table('users')->skip(10)->take(5)->get();

或者你也可以使用 limit 和 offset 方法：

$users = DB::table('users')
                ->offset(10)
                ->limit(5)
                ->get();

条件语句
有时候你可能想要子句只适用于某个情况为真是才执行查询。例如你可能只想给定值在请求中存在的情况下才应用 where 语句。 你可以通过使用 when 方法：

$role = $request->input('role');

$users = DB::table('users')
                ->when($role, function ($query, $role) {
                    return $query->where('role_id', $role);
                })
                ->get();

插入
查询构造器还提供了 insert 方法用于插入记录到数据库中。 insert 方法接收数组形式的字段名和字段值进行插入操作：

DB::table('users')->insert(
    ['email' => 'john@example.com', 'votes' => 0]
);

你甚至可以将数组传递给 insert 方法，将多个记录插入到表中

DB::table('users')->insert([
    ['email' => 'taylor@example.com', 'votes' => 0],
    ['email' => 'dayle@example.com', 'votes' => 0]
]);

如果数据表有自增 ID ，使用 insertGetId 方法来插入记录并返回 ID 值

$id = DB::table('users')->insertGetId(
    ['email' => 'john@example.com', 'votes' => 0]
);

DB::table('users')
            ->where('id', 1)
            ->update(['votes' => 1]);

DB::table('users')
    ->updateOrInsert(
        ['email' => 'john@example.com', 'name' => 'John'],
        ['votes' => '2']
    );

自增与自减
查询构造器还为给定字段的递增或递减提供了方便的方法。此方法提供了一个比手动编写 update 语句更具表达力且更精练的接口。

这两种方法都至少接收一个参数：需要修改的列。第二个参数是可选的，用于控制列递增或递减的量：

DB::table('users')->increment('votes');

DB::table('users')->increment('votes', 5);

DB::table('users')->decrement('votes');

DB::table('users')->decrement('votes', 5);

删除
DB::table('users')->delete();

DB::table('users')->where('votes', '>', 100)->delete();

悲观锁
查询构造器也包含一些可以帮助你在 select 语法上实现「悲观锁定」的函数。若想在查询中实现一个「共享锁」， 你可以使用 sharedLock 方法。 共享锁可防止选中的数据列被篡改，直到事务被提交为止 ：

DB::table('users')->where('votes', '>', 100)->sharedLock()->get();

或者，你可以使用 lockForUpdate 方法。使用 「update」锁可避免行被其它共享锁修改或选取：

DB::table('users')->where('votes', '>', 100)->lockForUpdate()->get();